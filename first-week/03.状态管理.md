## 为什么会出现例如 redux、mobx、recoil 等这一类数据管理库？他们分别解决了什么问题？

react 主要就是通过状态的改变然后再去更新视图的渲染，这个状态就显的尤为重要，在一些简单的点击操作中，可以很容易的拿到组件的状态，但是在一些复杂的react项目下，整个页面需要各种状态来维持数据的交互与展示。但是react基本的状态管理（props, state）只能管理当前组件内的状态，或者处理一下简单的组件交互，比如父子、兄弟组件之间传递状态等，一旦涉及到比较复杂的组件间数据交互时，处理逻辑就会变得非常复杂。于是出现了状态管理工具来实现统一管理。

### 状态管理的本质

- 数据共享
  要想共享数据，最简单的想法就是把状态设为全局的状态（redux），react 中的状态有两种，一种是组件内部的 state，一种就是全局的，所以在组件内进行状态的共享，有两种比较靠谱的办法，就是 【全局状态共享】和 【局部状态共享】，两者各有利弊，局部状态共享虽然可以像组件树一样拥有多例的能力，并且局部状态也可以跟随组件树创建或者销毁，保持干净易于维护，但是也造成了不够规范的问题，局部状态容易让逻辑变得混乱，排查问题也会比较困难。全局状态虽然很直观的可以看到状态的变化，但是容易收到污染，造成全局状态泛滥。
- 逻辑的组织
  状态不单单是数据项的堆砌，更重要的是把各项数据之间的逻辑、数据与其他系统模块之间的互动逻辑进行组织，比如说 A 需要在用户点击按钮时发生变化，而 B 又需要在 A 变化时跟着变化。针对这个问题，hooks 已经提供了比较完整的方案，比如：状态的副作用、性能优化等，让组件内部逻辑组件变得清晰可见，不需要全部将状态提升到全局去组织，而是只要关注当前状态的使用者是谁，然后交由hooks去处理。

#### 状态管理方案的选择

目前从下载量来看，Redux Mobx 以及 Recoil 是十分受欢迎的。这三个代表了不同的数据共享方式。

- Redux：是从 Flux 单项数据流架构演变而来的，状态清晰易懂
- Mbox：响应式双向数据绑定，多Store且可读写
- Recoil：原子式单向小回路，使用简单、拓展性高

##### Redux

redux 是从 Flux 单项数据流架构演变而来的，他的设计初衷是为了解决 js 中单页面应用状态管理越来越复杂的问题。他有三大原则：

- **单一数据源**：把所有的状态都放到一个 store 里面，一个应用中一般只有一个 store。
- **State 是只读的**：唯一改变 state 的方法是通过 dispatch 触发 action，action 描述了这次修改行为的相关信息。
- **通过纯函数来修改**：action触发修改依靠的是Reducer纯函数，reducer 会接收 state 和对应 action ，返回修改后的新 state；

**大致工作流程**

- 用户在页面上进行某些操作，通过 dispatch 发送一个 action。  
- Redux 接收到这个 action 后通过 reducer 函数获取到下一个状态。  
- 将新状态更新进 store，store 更新后通知页面进行重新渲染。  

redux的核心就是一个 发布-订阅 模式，view 订阅了 store 的变化，一旦 store 发生修改，就会通知所有的订阅者，view 接收到通知之后就会进行重新渲染。

**优缺点**

- 优点
  全局状态管理、单向数据流清晰严格
  代码风格统一规范，适合团队开发
- 缺点
  State过多十分臃肿，可能会导致性能问题；

##### Mobx

跟Redux一样，Mobx也是通过action修改state，再将修改映射到视觉views上,但是还是有些许不同的

- Mobx是响应式双向数据绑定，而 Redux 是 Flux 流派的单向数据流
- 采用观察者模式，当状态改变时，所有衍生都会进行原子级的自动更新，因此永远不可能观察到中间值。
- Mobx是多Store且可读写，而Redux 是唯一中心Store且只支持读操作

**核心思想**

- State(状态）：多个store数据源，mobx也支持单向数据流传递；
- Derivations(衍生)：任何源自状态并且不会再有任何进一步的相互作用的东西就是衍生。类似 Redux 中的 Reducer。Mobx 有两种形式的衍生：Computed Values（计算值）— 可以使用纯函数(pure function)从当前可观察状态中衍生出的值；Reactions(反应) - Reactions 是当状态改变时需要自动发生的副作用，也是使用较多的衍生；
- Actions(动作)：Actions是唯一可以修改State的入口；

**优缺点**

- 优点
    多Store源相互独立，不需要关注副作用影响
    代码量少，没有像Redux样板代码的束缚
- 缺点：
    过于自由，灵活使用的背后是缺少规范代码，导致团队代码风格不统一
    因为没法规范统一，不适用于大型复杂项目

##### Recoil

Recoil是Facebook开发的状态管理库，用于React项目的状态管理, 而上面所说的Redux、Mobx 它们本身并不是 React 库，借助这些库的能力来实现状态管理，使用成本较高，还需要编写大量冗长的代码。
Recoil 为了解决 React 全局数据流管理的问题，采用分散管理原子状态的设计模式。Recoil 提出了一个新的状态管理单位 Atom，它是可更新和可订阅的，当一个 Atom 被更新时，每个被订阅的组件都会用新的值来重新渲染。如果从多个组件中使用同一个 Atom ，所有这些组件都会共享它们的状态。
可以把 Atom 想象为为一组 state 的集合，改变一个 Atom 只会渲染特定的子组件，并不会让整个父组件重新渲染。



